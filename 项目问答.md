1. 前后端分离整个完整的流程是怎么样的？
答： 一般前后端分离主要就是为了实现分开开发和分开部署。所以我新建了一个前端项目，包括前端业务代码以及node server。将打包后的静态资源上传到cdn， node server负责读取打包后最新的html以实现页面的更新。一个仓库对应一个集群。由于页面需要实现灰度， 所以将一个集群分成两个组，对应不同的内网域名以及代码版本。当用户输入一个地址时， 会先在网关层根据灰度策略跳转不同的内网域名，进而加载不同版本的代码，展示不同的页面。

从两个角度触发，一个是代码仓库如何部署服务，一个是页面请求怎么访问服务。首先内部有云效系统，是一个58内部的cicd系统，之前前端很少用到，之前都是在自己机器上打包后将资源上传到cdn， 要么是跟着后端流程走。现在我在cicd系统定制了打包脚本，可以进行前端仓库打包和资源上传。打包完成后会在内部的云平台系统部署对应的node服务， 对外提供spa的模板页面。2. 当用户访问url时， 首先会进行域名解析，由运维来统一管理，最终解析到的时ngnix服务器，在ngnix中根据请求的location进行转发到对应的node服务。location的upstream别名对应的是node服务的集群别名，实际上是一组内网ip。

为什么很少用cicd: 总的来说两方面，一是团队规模小，二是公司内部的流程规范系统比较原始。因为之前前端规模比较小，我们团队也就67个人，公司内部的基础设施建设不是很完善。组长对这方面也不是很了解，所以对此关注比较少。但是随着规模增加，对流程规范比较迫切，公司内部也往这方面投入资源去建设。（打包机之前没有安装node, 组长对这方面也不是很了解，所以对此关注比较少）

```打包脚本
export NODE_HOME=/usr/local/nodejs/$env_version # 选择node版本
yarn install # 安装依赖
yarn build # 打包

tar -zcf all.tar.gz * # 进入dist目录，通过tar命令将所有文件做成一个压缩包

curl -F "file=@all.tar.gz" http://pages.corp.anjuke.com/yun/fileupload -F "site=${site}" -v # 通过curl命令将打包后的文件上传到cdn
```

```ngnix
upstream mysvr1 {
  server 127.0.0.1:7878;
  server 192.168.10.121:3333 backup;
}
location / { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
  root $doc_root_dir; #静态资源根目录
  proxy_pass http://mysvr1; #请求转向“mysvr1”定义的服务器列表
}
```
2. 对前后端分离的理解， 你做了哪些工作
答：我觉得前后端分离最重要的就是与后端解耦，实现分开开发和分开部署，还能提高开发效率。所以我主要做了以下几方面的工作： 1. 根据团队实际情况，选择合适的技术栈， 建立前端自己的仓库和node server（node作为静态服务器返回页面的html） 2. 由于之前数据是由php直出的，字段命名比较随意。所以这次也与后端团队沟通，制定了api规范 3. 使用axios封装并请求后端接口，注入数据

首先是对前端工作流程的规划: 相对于之前php的开发流程，前端需要自己接入cicd系统；之前静态资源文件是由后端服务托管，现在都上传到cdn；对于入口文件有三个方案：1. ngnix托管，2. 通过node server返回html（协商缓存），3. 由php管理。考虑到之后可能会有ssr以及bff的可能，所以选择了第二种方案。落实到仓库上，就是前端仓库中既有react/vue，又有node server。

gitrepo -> cicd -> 同步cdn；触发云平台机器部署
这是公司内部的基础建设， 大致是cicd和云平台是两套独立的系统， cicd内置一套配置系统，当部署构建完成会将产物搞成镜像上传到服务器，比如Java是一个jar包， 前端就是整个项目的压缩包， 接着触发一些脚本，发请求告诉云平台哪个集群在哪个环境部署了哪个版本，云平台会根据这些信息去部署机器，然后根据镜像地址下载对应的包，执行自定义的shell脚本启动服务。

```启动脚本
pm2 start dist/server.js
```
前后端联调阶段的约定，前后端团队共同制定api规范： 约定字段；定制axios,统一提供给各项目使用
如何统一升级axios? 1. 尽量向前兼容，确保格式一致，不做破坏性更新，项目初期考虑所有可能性 2. 目前把axios封装成script标签引入，也升级了四五个版本，目前运行正常，满足业务场景。 3 比如一般有改动都是添加一些请求头，响应头的处理或者状态码的处理。比如常见的反爬触发人机挑战，后端在响应头添加新字段，前端进行拦截。需要回归但不需要深度回归。如何更新script的cdn链接？1. 加时间戳会导致每次cdn缓存都是被击穿的，而且没有利用到强缓存，拖慢页面速度。2. 解决方法：node -> 根据script上的特殊标记来解析过滤出需要更新的cdn链接 -> 从redis中获取最新的cdn链接 -> 替换script标签中的cdn链接 -> 重新拼接html -> 返回给浏览器（更新redis需要提工单由运维去执行，虽然比较low,但频率低而且安全可靠）


3. 为什么一部分vue，一部分react
答：主要是涉及到组织架构的变更。不同的团队主要使用的技术栈不一样。而且从社区生态上来讲，react比vue更活跃。所以逐渐转向react。归根到底还是前端负责人的技术偏好。


4. 灰度分区是怎么实现的？出现问题怎么办？分支是怎么管理的？
答： 首先不管前端还是后端，我们一个仓库对应一个集群， 将集群分成多个组，比如a,b。一个内网域名对应不同集群的某个组，比如a域名对应所有集群的a分组。当浏览器发起请求时，会在前置网关判断该请求需要转发到哪个内网域名下。这样我们只需要控制分组的版本即可实现灰度分区。

如何控制版本号？ 这涉及到内部的cicd系统，每次打包构建都会生成不同的版本号。

出现问题怎么办？ 首先我们会先根据问题的紧急程度来判断是回滚还是修复上线。此外云平台还提供了历史记录的能力，方便快速回滚。一般使用蓝绿升级来调整流量观察线上情况。
```控制流量
upstream test.cc {
    server 192.168.8.143 weight=1;
    server 192.168.8.144 weight=2;
}
```

分支是怎么管理的？ 走release分支上线，所有的feature分支都先merge到release上同意构建，测试回归没有问题就准备上线，部署到灰度分组。等观察1-3天没有问题，将版本同步到全量分组，并将release分支 merge到master。需求是按批次上线的， 每次上线都会先走灰度分组，等确保上线没有问题后，再进行全量上线。


灰度策略不一致怎么办？？？灰度的目标就是让一部分用户抢先体验这个功能， 确保安全可靠以及满足用户需求，按城市策略。您说的问题可能跟我理解的灰度策略有一定的出入，类似于权限管理的角度，用户有权限就能看到这个功能。不知道是不是我对您提出的问题出现了认知偏差。


5. 为什么要用微前端？为什么要用qiankun?qiankun加载原理是什么？与其他框架有做对比吗？
答: 使用微前端主要有两个原因，第一个原因就是功能基本一致的页面需要嵌入到其他平台使用。重复开发没有必要。第二个原因是不同页面使用的技术栈不一致，vue和react都有。所以选择使用微前端。
原因： 1. 首先从业务角度出发， 我们主要一个面向经纪人的工作台，可以进行房源增值，数据分析，客户管理等。各功能模块之间比较独立， 适合微前端模式。 2. 从技术角度出发， 我们期望技术栈能有渐进式升级的能力，之前有的项目是vue2、react16,现在对于新的功能模块渐渐转向17，未来还可能是18 3. 公司内部在做资源整合，期望58，安居客，巧房这三个系统之间能够业务连贯，打通数据壁垒，不可避免的需要页面直接复用，涉及到各团队的合作，所以需要有一套统一的技术方案。

在技术选型上， 一开始考虑的是iframe比较简单，但实际采用后发现页面上有较多弹窗， 样式出现问题。于是就另谋出路， 正好当时qiankun正火热。本着折腾的心态，就尝试了一下。还有一个特殊的场景，巧房中内嵌安居客页面，如果使用iframe，会出现跨域问题，限制访问cookie，需要解决samesite=none的兼容问题（在不同版本的chrome下，对响应中set-cookie samesite=none的处理行为很奇怪）。所以我们需要一个比iframe更合适的替代方案。所以最终选择了qiankun。

qiankun的加载原理： qiankun是基于singal spa的，single-spa内部会对浏览器的路由进行劫持，我们会提前注册应用，执行start。当路由变更时，由singal-spa统一处理进行应用的激活与卸载。具体怎么实现的，精力有限，暂时没有深入研究。
qiankun相对于singal spa最核心的改变就是支持html entry和config entry两种方式接入子应用。使我们不需要修改应用的打包方式。另外qiankun提供了沙箱机制，对于应用中的脚本和样式进行隔离。还提供了prefetch的功能。
对于html entry来说，当active rule被激活时，qiankun会通过fetch的方式去获取子应用的htm，解析html中的脚本和样式，对于脚本资源文件也会通过fetch获取，为实现沙箱隔离将脚本放到with语句中执行。最后取出子应用导出的生命周期交给singal spa去调度。对于子应用的外部样式，也会通过fetch去获取，然后用style标签包裹，转化成内联样式。会动态插入/移除样式的link节点， 还有严格沙箱和实验性沙箱， 严格沙箱是shadow dom，实验性沙箱是添加特殊后缀，业务上我们一般使用css-module进行规避。

除了register microapp注册加载，还提供了loadMicroApp手动加载的方式，这种方式可以在应用启动后，根据业务逻辑动态加载子应用。

js沙箱隔离？
快照模式： 激活沙箱时，将window的快照信息存到windowSnapshot中， 如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。

proxy模式： qiankun 在实现 sandbox 时，先根据当前window创建fakewindow, 将window上的一些可配置的属性，通过defineProperty将属性描述符定义到fakewindow 上。然后通过proxy代理fakeWindow， 借助with语句将子应用js代码包裹修改运行时的全局指向。当子应用中需要添加(修改)全局变量时，直接在 fakeWindow 中添加(修改)；当子应用需要从全局变量中读取某个属性(方法)时，先从 fakeWindow 中获取，如果 fakeWindow 中没有，再从原生 window 中获取


6. 微前端架构是什么样的？基座有几个？同一个子应用在不同基座部署不同版本的代码该怎么办？
答： 主要是一个基座，多个子应用的模式。通过路由配置来进行子应用的注册。
首先对于不同的基座肯定是对于不同的集群的。这样的话，我们就能通过在不同的集群部署不同版本的代码来实现
7. 遇到过什么问题吗？
答： 比较棘手的可以说是一个jsonp问题。
8. 组件抽离是怎么考虑的？
答： 我觉得组件抽离的话需要考虑的就是普适应和易用性，两者需要平衡。不能为了让别人使用方便而过度封装， 也不能为了组件的通用性而设置很多参数和回调。需要结合实际情况来进行两者的平衡。在此基础上，组件还需要有一定的扩展性。
9. 项目投放率增加从技术角度有做哪些改进吗？
10. 表达式编辑器是怎么做的？你觉得有什么难点吗？
交互是自己想的吗？为什么要参考这些?
11. 虚拟列表怎么实现的？
12. 数据量有多少？为什么会卡顿？