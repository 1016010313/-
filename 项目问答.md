1. 前后端分离整个完整的流程是怎么样的？
从两个角度出发，一个是代码仓库如何部署服务，一个是页面请求怎么访问服务。首先内部有云效系统，是一个58内部的cicd系统，之前前端很少用到，之前都是在自己机器上打包后将资源上传到cdn， 要么是跟着后端流程走。现在我在cicd系统定制了打包脚本，可以进行前端仓库打包和资源上传。打包完成后会在内部的云平台系统部署对应的node服务， 对外提供spa的模板页面。2. 当用户访问url时， 首先会进行域名解析，由运维来统一管理，最终解析到的是ngnix服务器，在ngnix中根据请求的location进行转发到对应的node服务。location的upstream别名对应的是node服务的集群别名，实际上是一组内网ip。

为什么很少用cicd: 总的来说两方面，一是团队规模小，二是公司内部的流程规范系统比较原始。因为之前前端规模比较小，我们团队也就67个人，公司内部的基础设施建设不是很完善。组长对这方面也不是很了解，所以对此关注比较少。但是随着规模增加，对流程规范比较迫切，公司内部也往这方面投入资源去建设。（打包机之前没有安装node, 组长对这方面也不是很了解，所以对此关注比较少）

```打包脚本
export NODE_HOME=/usr/local/nodejs/$env_version # 选择node版本
yarn install # 安装依赖
yarn build # 打包

tar -zcf all.tar.gz * # 进入dist目录，通过tar命令将所有文件做成一个压缩包

curl -F "file=@all.tar.gz" http://pages.corp.anjuke.com/yun/fileupload -F "site=${site}" -v # 通过curl命令将打包后的文件上传到cdn
```

```ngnix
upstream mysvr1 {
  server 127.0.0.1:7878;
  server 192.168.10.121:3333 backup;
}
location / { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
  root $doc_root_dir; #静态资源根目录
  proxy_pass http://mysvr1; #请求转向“mysvr1”定义的服务器列表
}
```
2. 对前后端分离的理解， 你做了哪些工作
答：我觉得前后端分离最重要的就是与后端解耦，实现分开开发和分开部署，还能提高开发效率。所以我主要做了以下几方面的工作
首先是对前端工作流程的规划: 相对于之前php的开发流程，前端需要自己接入cicd系统；之前静态资源文件是由后端服务托管，现在都上传到cdn；对于入口文件有三个方案：1. ngnix托管，2. 通过node server返回html（协商缓存），3. 由php管理。考虑到之后可能会有ssr以及bff的可能，所以选择了第二种方案。落实到仓库上，就是前端仓库中既有react/vue，又有node server。

gitrepo -> cicd -> 同步cdn；触发云平台机器部署
这是公司内部的基础建设， 大致是cicd和云平台是两套独立的系统， cicd内置一套配置系统，当部署构建完成会将产物搞成镜像上传到服务器，比如Java是一个jar包， 前端就是整个项目的压缩包， 接着触发一些脚本，发请求告诉云平台哪个集群在哪个环境部署了哪个版本，云平台会根据这些信息去部署机器，然后根据镜像地址下载对应的包，执行自定义的shell脚本启动服务。

```启动脚本
pm2 start dist/server.js
```
前后端联调阶段的约定，前后端团队共同制定api规范： 约定字段；定制axios,统一提供给各项目使用
如何统一升级axios? 1. 尽量向前兼容，确保格式一致，不做破坏性更新，项目初期考虑所有可能性 2. 目前把axios封装成script标签引入，也升级了四五个版本，目前运行正常，满足业务场景。 3 比如一般有改动都是添加一些请求头，响应头的处理或者状态码的处理。比如常见的反爬触发人机挑战，后端在响应头添加新字段，前端进行拦截。需要回归但不需要深度回归。如何更新script的cdn链接？1. 加时间戳会导致每次cdn缓存都是被击穿的，而且没有利用到强缓存，拖慢页面速度。2. 解决方法：node -> 根据script上的特殊标记来解析过滤出需要更新的cdn链接 -> 从redis中获取最新的cdn链接 -> 替换script标签中的cdn链接 -> 重新拼接html -> 返回给浏览器（更新redis需要提工单由运维去执行，虽然比较low,但频率低而且安全可靠）


3. 为什么一部分vue，一部分react
答：主要是涉及到组织架构的变更。不同的团队主要使用的技术栈不一样。而且从社区生态上来讲，react比vue更活跃。所以逐渐转向react。归根到底还是前端负责人的技术偏好。


4. 灰度分区是怎么实现的？出现问题怎么办？分支是怎么管理的？
答： 首先不管前端还是后端，我们一个仓库对应一个集群， 将集群分成多个组，比如a,b。一个内网域名对应不同集群的某个组，比如a域名对应所有集群的a分组。当浏览器发起请求时，会在前置网关判断该请求需要转发到哪个内网域名下。这样我们只需要控制分组的版本即可实现灰度分区。

如何控制版本号？ 这涉及到内部的cicd系统，每次打包构建都会生成不同的版本号。

出现问题怎么办？ 首先我们会先根据问题的紧急程度来判断是回滚还是修复上线。此外云平台还提供了历史记录的能力，方便快速回滚。一般使用蓝绿升级来调整流量观察线上情况。
```控制流量
upstream test.cc {
    server 192.168.8.143 weight=1;
    server 192.168.8.144 weight=2;
}
```

分支是怎么管理的？ 走release分支上线，所有的feature分支都先merge到release上统一构建，测试回归没有问题就准备上线，部署到灰度分组。等观察1-3天没有问题，将版本同步到全量分组，并将release分支 merge到master。需求是按批次上线的， 每次上线都会先走灰度分组，等确保上线没有问题后，再进行全量上线。


灰度策略不一致怎么办？？？灰度的目标就是让一部分用户抢先体验这个功能， 确保安全可靠以及满足用户需求，按城市策略。您说的问题可能跟我理解的灰度策略有一定的出入，类似于权限管理的角度，用户有权限就能看到这个功能。不知道是不是我对您提出的问题出现了认知偏差。


5. 为什么要用微前端？为什么要用qiankun?qiankun加载原理是什么？与其他框架有做对比吗？
答:
原因： 1. 首先从业务角度出发， 我们主要一个面向经纪人的工作台，可以进行房源增值，数据分析，客户管理等。各功能模块之间比较独立， 适合微前端模式。 2. 从技术角度出发， 我们期望技术栈能有渐进式升级的能力，之前有的项目是vue2、react16,现在对于新的功能模块渐渐转向17，未来还可能是18 3. 公司内部在做资源整合，期望58，安居客，巧房这三个系统之间能够业务连贯，打通数据壁垒，不可避免的需要页面直接复用，涉及到各团队的合作，所以需要有一套统一的技术方案。

在技术选型上， 一开始考虑的是iframe比较简单，但实际采用后发现页面上有较多弹窗， 样式出现问题。于是就另谋出路， 正好当时qiankun正火热。本着折腾的心态，就尝试了一下。还有一个特殊的场景，巧房中内嵌安居客页面，如果使用iframe，会出现跨域问题，限制访问cookie，需要解决samesite=none的兼容问题（在不同版本的chrome下，对响应中set-cookie samesite=none的处理行为很奇怪）。所以我们需要一个比iframe更合适的替代方案。所以最终选择了qiankun。

qiankun的加载原理： qiankun是基于singal spa的，single-spa内部会对浏览器的路由进行劫持，我们会提前注册应用，执行start。当路由变更时，由singal-spa统一处理进行应用的激活与卸载。具体怎么实现的，精力有限，暂时没有深入研究。
qiankun相对于singal spa最核心的改变就是支持html entry和config entry两种方式接入子应用。使我们不需要修改应用的打包方式。另外qiankun提供了沙箱机制，对于应用中的脚本和样式进行隔离。还提供了prefetch的功能。
对于html entry来说，当active rule被激活时，qiankun会通过fetch的方式去获取子应用的htm，解析html中的脚本和样式，对于脚本资源文件也会通过fetch获取，为实现沙箱隔离将脚本放到with语句中执行。最后取出子应用导出的生命周期交给singal spa去调度。对于子应用的外部样式，也会通过fetch去获取，然后用style标签包裹，转化成内联样式。会动态插入/移除样式的link节点， 还有严格沙箱和实验性沙箱， 严格沙箱是shadow dom，实验性沙箱是添加特殊后缀，业务上我们一般使用css-module进行规避。

除了register microapp注册加载，还提供了loadMicroApp手动加载的方式，这种方式可以在应用启动后，根据业务逻辑动态加载子应用。

js沙箱隔离？
快照模式： 激活沙箱时，将window的快照信息存到windowSnapshot中， 如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。

proxy模式： qiankun 在实现 sandbox 时，先根据当前window创建fakewindow, 将window上的一些可配置的属性，通过defineProperty将属性描述符定义到fakewindow 上。然后通过proxy代理fakeWindow， 借助with语句将子应用js代码包裹修改运行时的全局指向。当子应用中需要添加(修改)全局变量时，直接在 fakeWindow 中添加(修改)；当子应用需要从全局变量中读取某个属性(方法)时，先从 fakeWindow 中获取，如果 fakeWindow 中没有，再从原生 window 中获取


6. 微前端架构是什么样的？基座有几个？同一个子应用在不同基座部署不同版本的代码该怎么办？
答：
首先是基座加子应用的模式（master-slave）,基座主要负责子应用的管理、菜单布局、全局数据的获取、全局工具注册，比如event=emitter、埋点、错误监控、全局的external的cdn(如react,react-dom等其他工具)等
子应用主要负责提供自己的html entry或者config entry
anjuke.com/micro/master/
anjuke.com/micro/slave-1/

同一个子应用在不同基座部署不同版本的代码该怎么办？首先我们没有遇到过这种需求，我想想啊，我们可以为集群新开个分组，另外一个新的内网域名，配置新基座的入口请求打到新的域名上再进行转发。这样基座1和基座2就可以分别请求到不同的内网域名，进而请求到同个集群的不同分组，从而实现不同基座部署不同版本的代码。但是我感觉凭空制造了复杂度，如果真的有这种需求，我觉得我会给这个需求投个反对票。你觉得我这个思路如何？或者给点指导性意见。


7. 微前端遇到过什么问题吗？
答： 比较棘手的可以说是一个jsonp问题，支持多种菜单布局， qiankun html entry会多发起一次请求。
query(路由跳转时有可能丢失参数) vs params router


8. 组件抽离是怎么考虑的？
答： 我觉得组件抽离的话有以下几个点考虑：
第一点是组件抽离要有意义， 一般流程是现在业务组件库落地实现，如果后面发现具有通用性，才会考虑花时间抽离出来。第二点是组件抽离需要考虑使用者的感受。考虑的就是普适应和易用性，两者需要平衡。不能为了让别人使用方便而过度封装， 也不能为了组件的通用性而设置很多参数和回调。需要结合实际情况来进行两者的平衡。第三点是确保组件设计合理，团队中要有机制review 组件设计，尽量保证组件的可扩展性， 为后面的迭代预留空间。要求类型完善，尽量使用ts进行约束。具体到业务上一般抽离最多的是布局组件和内容组件，类似于ant design的tabs和tabs.panel的关系。

它会减少需要书写的模板吗？一个好的组件应该是能减少使用时书写的代码量。并且性能上是进行过一定程度的优化， 还需要编写合适的文档和demo。如果可以的话最好写一些用例进行单元测试，保证组件安全可靠。


最近比较火的headless component无头组件稍微关注了下，感觉还挺好玩的。核心思路时通过纯js组装交互逻辑、事件监听、数据管理。然后通过adapt胶水层链接到react/vue/slvet等框架。由框架层面去实现dom节点，再结合一些类似tailwindcss实现完整的组件功能

9. 项目投放率增加从技术角度有做哪些改进吗？



10. 表达式编辑器是怎么做的？你觉得有什么难点吗？
产品层面： 在参与珊瑚海低代码平台共建的过程中，我发现这个平台缺少逻辑处理的功能， 不能对api、数据、交互做一些逻辑处理。于是想着怎么给这个低代码平台添砖加瓦。第二是珊瑚海是使用dsl来描述页面，它的dsl其实就是定制版的json, 换句话来说就是用json来描述css和组件。也就是说要开发这个逻辑编辑器必须也通过json的方式。后来经过一段时间调研，发现可以通过jsonlogic书写逻辑。（一是因为目标人群是产品运营等非技术人员，让他们写代码不现实；二是如果写代码那么势必需要将代码进行打包转义，然后通过jsonp或者注入脚本的方式加载到页面上，平台不支持）。但是直接写jsonlogic学习成本高，上手高，所以接下来要考虑的就是怎么降低使用门槛。经过对行业json编辑的调研， 发现可以将json转化成树状表单的形式，一组key-value就是一行表单节点，包含若干个form Item用来编辑这个节点的类型，数据，子节点等。
技术层面： 最开始遇到了性能问题，当滚动或者展开收起时会有明显的卡顿。使用react profile插件和useWhyDidYouUpdate定位问题， 加了一些usememo/usecallback/memo等优化，效果稍微好一点，但是数据量变大时，依旧是会卡顿。所以又添加了虚拟列表的功能。


交互是自己想的吗？为什么要参考这些?
11. 虚拟列表怎么实现的？
12. 数据量有多少？为什么会卡顿？
每组key-value都是一行表单节点，一行节点往少了说有30个dom,稍微复杂一点的列表页大概需要400行左右json数据，所以一般一个页面有30*400=12000 个dom节点。这是往少了说的， 因为编辑器是一个弹窗，在弹窗之下还有一些其他的模块，所以整个页面的节点只会多的多。